# 垃圾回收算法

## 复制算法

- 将可用内存按容量划分为相等的两部分，每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清除第一块内存，再将第二块上的对象复制到第一块。
- 实现方便，运行高效，不用考虑内存碎片，但是内存利用率只有一半。

## 标记清除算法

- 分为**标记**和**清除**两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。
- 算法简单，但是有两个缺点：
  - 1、效率不高，标记和清除的效率都很低；
  - 2、空间问题，会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。

## 标记整理算法

- 标记过程仍然与 “标记 - 清除” 算法一样，但不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存，形成一版连续的内存区域。
- 解决标记 - 清除算法产生的大量内存碎片问题；当对象存活率较高时，也解决了复制算法的空间效率问题，不过它本身也存在时间效率方面的问题。

## 分代收集算法

- 根据对象的生存周期，将堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用**复制**算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用**标记 - 整理** 或者 **标记 - 清除**。
- 严格地说，这并非是一种算法，而是一种思想，或者说是一种复合算法。

