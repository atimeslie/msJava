## 常用算法

来看算法部分的知识点汇总，如下图所示。

<img src="http://s0.lgstatic.com/i/image2/M01/8A/C1/CgoB5l14oT6ARislAAIosv-_rkU883.png" alt="img" style="zoom:80%;" />

算法题的常用解题方法。

1. 复杂度是衡量算法好坏的标准之一，我们需要掌握计算算法时间复杂度和空间复杂度的方法。计算时间复杂度的方法一般是找到执行次数最多的语句，然后计算语句执行次数的数量级，最后用大写 O 来表示结果。

2. 常用的字符串匹配算法，了解不同算法的匹配思路。

3. 排序也是经常考察的知识点，排序算法分为插入、交换、选择、归并、基数五类，其中快速排序和堆排序考察的频率最高，要重点掌握，需要能够手写算法实现。

4. 常用的查找算法，包括二分查找、二叉排序树、B 树、Hash、BloomFilter 等，需要了解它们的适用场景，例如二分查找适合小数量集内存查找，B 树适合文件索引，Hash 常数级的时间复杂度更适合对查找效率要求较高的场合，BloomFilter 适合对大数据集进行数据存在性过滤。

算法的知识点比较多，提高算法解题能力需要适当刷题，但不能单纯依靠刷题来解决问题。需要掌握几种常用解题思路与方法，才能以不变应万变。这里讲一下：分治、动态规划、贪心、回溯和分支界定这五种常用的算法题解题方法，来看看它们分别适用于什么场景，如何应用。

## 分治法

分治法的思想是将一个难以直接解决的复杂问题或者大问题，分割成一些规模较小的相同问题，分而治之。比如快速排序、归并排序等都是应用了分治法。

适合使用分治法的场景需要满足三点要求：

1. 可以分解为子问题；

2. 子问题的解可以合并为原问题的解；

3. 子问题之间没有关联。


使用分治法解决问题的一般步骤如下图表格所示。

![img](http://s0.lgstatic.com/i/image2/M01/8A/C2/CgoB5l14oT-AOl2vAABkMCakhSg069.png)

1. 第一步，要找到最小子问题的求解方法；

2. 第二步，要找到合并子问题解的方法；

3. 第三步，要找到递归终止条件。

## 动态规划法

动态规划法，与分治法类似，也是将问题分解为多个子问题。与分治法不同的是，子问题的解之间是有关联的。前一子问题的解，为后一子问题的求解提供了有用的信息。动态规划法依次解决各子问题，在求解每一个子问题时，列出所有局部解，通过决策保留那些有可能达到全局最优的局部解。最后一个子问题的解就是初始问题的解。

使用动态规划的场景需要也满足三点条件：

1. 子问题的求解必须是按顺序进行的；

2. 相邻的子问题之间有关联关系；

3. 最后一个子问题的解就是初始问题的解。


使用动态规划解决问题时，如上图表格第二行。

1. 第一步，先要分析最优解的性质；

2. 第二步，递归的定义最优解；

3. 第三步，记录不同阶段的最优值；

4. 第四步，根据阶段最优解选择全局最优解

## 贪心算法

第三个贪心算法，因为它考虑的是局部的最优解，所以贪心算法不是对所有问题都能得到整体最优解。贪心算法的关键是贪心策略的选择。贪心策略必须具备无后效性，就是说某个状态以后的过程不会影响以前的状态，只与当前状态有关。

贪心算法使用的场景必须满足两点：

1. 局部最优解能产生全局最优解；

2. 就是刚才说的必须具备无后效性。


如下图所示，使用贪心算法解题的一般步骤为：

![img](http://s0.lgstatic.com/i/image2/M01/8A/E1/CgotOV14oT-AP4CcAABsEmtOf8k652.png)

1. 第一步，先分解为子问题；

2. 第二步、按贪心策略计算每个子问题的局部最优解；

3. 第三步，合并局部最优解。

## 回溯算法

回溯算法实际上是一种深度优先的搜索算法，按选优的条件向前搜索，当探索到某一步时，发现原先选择并不优或达不到目标，就退回上一步重新选择，这种走不通就退回再走的方法就是回溯法。

回溯法适用于能够深度优先搜索，并且需要获取解空间的所有解的场合，例如迷宫问题等。

如上图所示，回溯法一般的解题步骤为：

1. 第一步先针对所给问题，确定问题的解空间；

2. 第二步、确定结点的扩展搜索规则；

3. 第三步，以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

## 分支界定法

最后是分支界定法，与回溯法的求解目标不同。回溯法的求解目标是找出满足约束条件的所有解，而分支界定法的求解目标则是找出满足约束条件的一个解。

分支界定法适用于广度优先搜索，并且获取解空间的任意解就可以的场合，例如求解整数规划问题。

如上图所示，分支界定法一般的解题步骤：

1. 第一步先确定解的特征；

2. 第二步在确定子节点搜索策略，例如是先入先出，还是先入后出；

3. 第三步通过广度优先遍历寻找解。