# 设计模式总结

## 1.设计模式一般遵循哪些原则？

设计模式一般遵循六大原则：

**（1）单一职责原则（Single Responsibility Principle）**：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。

**（2）里氏代换原则（Liskov Substitution Principle）**：所有引用基类的地方必须能透明地使用其子类的对象。简单地说，一个软件如果使用的是一个父类的话,那么一定适用于其子类,而察觉不出父类。

**（3）依赖倒置原则（Dependence Inversion Principle）**：细节应该依赖于抽象，而抽象不应该依赖于细节。依赖倒置原则的核心思想是面向接口编程。

**（4）接口隔离原则（Interface Segregation Principle）**：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。

**（5）迪米特法则（最少知道原则）（Demeter Principle）**：一个对象应该对其他对象保持最少的了解，即尽量降低耦合。

**（6）合成复用原则（Composite Reuse Principle）**：尽量首先使用合成/聚合的方式，而不是使用继承。

**点评：**

设计模式的六大原则基本上都围绕着两点展开：**高内聚**和**松耦合**。如何使你的程序做到这两点就是看你对设计模式的理解程度了。设计模式是一种思想，可以去指导你的行为。理解和掌握了设计模式，并不是说将 23 种设计模式背下来就行了，而是需要你对整个面向对象设计要有非常深刻的理解，将整个设计模式的思想要根深蒂固的植入到你的头脑中。从**两大要求**到**六大原则**再到**二十三种设计模式**，都是对面向对象的不同诠释。

## 2.  你在开发中都用到了那些设计模式？用在什么场合？为什么使用这些设计模式？

**（1）代理模式**：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。通常是需要修改或屏蔽某一个或若干个类的部分功能，复用另外一部分功能。 常见的比如说日志代理、缓存代理等；

**（2）适配器模式**：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。

**（3）模板方法模式**：提供一个抽象类，规范整个流程。其中部分逻辑以具体方法实现，部分逻辑声明为抽象方法，让不同的子类实现不同的业务逻辑。适用于固定流程下有部分公共逻辑也有部分个性化逻辑的场景。

## 3. 说说开源软件或者JDK中的一些常见的设计模式

**1. 创建型模式**:

**（1） 工厂模式**：返回具体对象的方法。比如说：java.lang.Proxy#newProxyInstance()；

**（2） 抽象工厂模式**：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型。简单地说，一个创建新对象的方法，返回的却是接口或者抽象类的，比如说：java.util.Calendar#getInstance()；

**（3） 单例模式**：用来确保类只有一个实例。比如说：java.lang.Runtime#getRuntime()；

**（4） Builder 建造者模式**：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建。建造模式通常也使用方法链接来实现。比如说：java.lang.StringBuilder#append()；

**（5） 原型模式**：使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时，就可以使用这种模式，而不重新创建一个新的实例，你可以拷贝一个对象并直接修改它。比如说：java.lang.Object#clone()

**2. 结构型模式：**

**（1）适配器模式**：用来把一个接口转化成另一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。比如说：java.util.Arrays#asList()；

**（2）装饰器模式**：动态的给一个对象附加额外的功能，这也是子类的一种替代方式。可以看到，在创建一个类型的时候，同时也传入同一类型的对象。比如说：java.io.BufferedInputStream(InputStream)；

**（3） 代理模式**：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象。比如说：java.lang.reflect.Proxy

**（4） 外观模式**：给一组组件，接口，抽象，或者子系统提供一个简单的接口。比如说：java.lang.Class；

**（5）桥接模式**：将抽象和实现进行了解耦，这样使得抽象和实现可以独立地变化。比如说 jdbc 的实现，java.sql.Driver

**（6）组合模式**：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。简单地说，即某个类型的方法同时也接受自身类型作为参数。比如说：java.util.Map#putAll(Map)；

**（7）享元模式**：运用共享技术（如缓存）来有效地支持大量细粒度对象的复用。比如说：java.lang.Integer#valueOf(int)

**3. 行为型模式：**

**（1）策略模式**：将一组算法封装成一系列对象。通过传递这些对象可以灵活的改变程序的功能。比如说：java.util.Comparator#compare()

**（2）模板方法模式**：让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。比如说：java.util.Collections#sort()

**（3）观察者模式**：它使得一个对象可以灵活的将消息发送给感兴趣的对象。比如说java.util.EventListener

**（4）迭代器模式**：提供一个一致的方法来顺序访问集合中的对象，这个方法与底层的集合的具体实现无关。比如说：java.util.Iterator

**（5）责任链模式**：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。比如说：java.util.logging.Logger#log()

**（6）命令模式**：将操作封装到对象内，以便存储，传递和返回。比如说：java.lang.Runnable

**（7）备忘录模式**：生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。比如说，Date对象通过自身内部的一个long值来实现备忘录模式。

**（8）状态模式**：通过改变对象内部的状态，使得你可以在运行时动态改变一个对象的行为。比如说：java.util.Iterator

**（9）访问者模式**：提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。比如说：javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor

**（10）中介者模式**：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。比如说java.util.concurrent.Executor#execute()

**（11）解释器模式**：定义了一个语言的语法，然后解析相应语法的语句。比如说：java.util.Pattern

## ４．为什么要用单例模式?手写几种线程安全的单例模式?

 单例模式在框架和项目中应用广泛 ，像线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象经常被设计成单例，主要在于它有以下优点：

 （1）对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；

 （2）由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

 （3）可以为整个系统提供一个全局访问点。

**实现：**

单例模式有两种经典实现方式：

- **饿汉式单例**：即在类加载初始化的时候就立即创建实例；
- **懒汉式单例**：等到真正使用的时候才去创建实例，不用时不去主动创建。

下面分别予以说明：

 （1）饿汉式单例

```java
/**
 * 饿汉式单例
 */
public class SingletonTest {

    // 1. 类对象
    private static  SingletonTest instance  = new  SingletonTest();

    // 2. 构造函数 设置为 私有权限，禁止他人创建实例
    private SingletonTest() {
    }

    // 3. 通过调用静态方法获得单例
    public static  SingletonTest newInstance() {
        return instance;
    }
}
```

 （2）懒汉式单例

```java
/**
 *  懒汉式单例
 */
public class SingletonTest {

    // 1. 创建静态内部类
    private static class SingletonTestHolder {
        // 在静态内部类里创建单例，由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性
        private static  SingletonTest instance  = new SingletonTest();
    }

    // 2. 构造函数设置为私有权限，禁止他人创建实例
    private SingletonTest() {
    }

    // 3. 延迟加载，按需创建
    public static  SingletonTest getInstance() {
        // 在调用装载被初始化时，会初始化它的静态域，从而创建单例；
        return SingletonTestHolder.instance;
    }
}
```

**点评**：

单例模式是设计模式中出现频率最高的，一方面单例模式形式简单优点明显，所以在框架和开发中应用广泛 ；另一方面考察点相对来说也比较多，其他考察点还包括：

 （1）单例模式的其他实现方式，如同步锁、双重校验锁、枚举等；

 （2）单例模式的缺点（优点前面已经提到了）。



A、 单例模式没有抽象层，扩展很困难，基本上只能修改原有代码；

 B、单例类的职责过重，在一定程度上违背了“单一职责原则”；

 C、不适用于变化的对象，如果对象在不同的场景要保存不同的状态，那么单例可能出现数据上的错误。

 （3）还有就是双重锁的潜在安全问题及改进。这一点这里不再展开，大家可以参考[彻头彻尾理解单例模式与多线程](https://blog.csdn.net/justloveyou_/article/details/64127789)这篇文章，本质上是因为创建对象 new SingletonTest() 这个过程可能不是原子的，需要加上 volatile 来禁止重排序。

##  5. 使用工厂模式最主要的好处是什么？一般什么情况下使用？工厂模式和抽象工厂模式的差异在哪里？

*使用工厂模式最主要的好处是什么*

 （1）把对象的创建和调用解耦，当对象的创建发生变化时调用方无须感知，只需要在工厂里面修改即可，提升代码可维护性；

 （2） 对象创建过程很复杂时降低代码重复度和复杂度。

*一般什么情况下使用*

 （1）对象的创建过程/实例化准备工作很复杂，需要初始化很多参数、查询数据库等；

 （2）类本身有好多子类，这些类的创建过程在业务中容易发生改变，或者对类的调用容易发生改变；

 （3）类的构造方法有多个，容易混淆；可以用一系列名字不同的工厂方法来代替不同的构造方法；

 （4）类需要提供给第三方使用。

*工厂模式和抽象工厂模式的差异在哪里？*

工厂方法模式与抽象工厂模式最大的区别在于：在工厂方法模式中，工厂创造的是一个产品，而在抽象工厂模式中，工厂创造的是一个产品族，然后真正的产品是挑选不同的产品族来组合。

**点评：**

设计模式的一个重要原则是针对接口编程，不要依赖实现类。工厂模式遵循了这一个原则，而且遵循开闭原则，即对于组件功能的扩展是开放的，是允许对其进行功能扩展的（“**开**”)；同时对于原有代码的修改是封闭的，即不应该修改原有的代码（“**闭**”) 。